#include "NewChartPCH.h"
#include "NewChartVisualizer.h"
#include <qwt/qwt_plot_canvas.h>
#include <qwt/qwt_scale_draw.h>
#include <qwt/qwt_scale_widget.h>
#include <qwt/qwt_plot_layout.h>
#include <qwt/qwt_plot_panner.h>
#include <qwt/qwt_plot_magnifier.h>
#include <qwt/qwt_legend.h>
#include "NewChartPicker.h"
#include "NewChartMarker.h"


QWidget* NewChartVisualizer::createWidget( std::vector<QObject*>& actions )
{
    activeSerieCombo = new QComboBox();
    activeSerieCombo->addItem(QString::fromUtf8("No active serie"));
    activeSerieCombo->setEnabled(false);
    connect(activeSerieCombo, SIGNAL(currentIndexChanged(int)), this, SLOT(setActiveSerie(int)));

    actions.push_back(activeSerieCombo);

    QwtText txt(getName().c_str());
    qwtPlot.reset(new QwtPlot(txt, nullptr));
    qwtPlot->setAutoReplot(true);
    if (isShowLegend()) {
        QwtLegend* legend = new QwtLegend();
        legend->setItemMode(QwtLegend::ClickableItem);
        qwtPlot->insertLegend( legend, QwtPlot::RightLegend );
    }
    qwtPlot->canvas()->setFocusIndicator(QwtPlotCanvas::ItemFocusIndicator);

    for ( int i = 0; i < QwtPlot::axisCnt; i++ )    {
        QwtScaleWidget *scaleWidget = qwtPlot->axisWidget( i );
        if ( scaleWidget ) {
            scaleWidget->setMargin( 0 );
        }
        /*QwtScaleDraw *scaleDraw = qwtPlot->axisScaleDraw( i );
        if ( scaleDraw ) {
            scaleDraw->enableComponent( QwtAbstractScaleDraw::Backbone, false );
        }*/
    }
    qwtPlot->plotLayout()->setAlignCanvasToScales( true );

    /*zoomer.reset(new QwtPlotZoomer(qwtPlot->canvas()));
    zoomer->setStateMachine(new QwtPickerDragRectMachine);
    zoomer->setTrackerMode(QwtPicker::ActiveOnly);
    zoomer->setRubberBand(QwtPicker::RectRubberBand); */

    ( void ) new QwtPlotPanner( qwtPlot->canvas() );
    ( void ) new QwtPlotMagnifier( qwtPlot->canvas() );
    picker = new NewChartPicker( qwtPlot.get() );
    connect(picker, SIGNAL(serieSelected(QwtPlotItem*)), this, SLOT(onSerieSelected(QwtPlotItem*)));

    connect(qwtPlot.get(), SIGNAL(legendClicked(QwtPlotItem*)), this, SLOT(onSerieSelected(QwtPlotItem*)));
    //qwtMarker.reset(new QwtPlotMarker());
    qwtMarker = new NewChartMarker();
    qwtMarker->setLabel(QString(""));
    qwtMarker->setLabelAlignment(Qt::AlignLeft | Qt::AlignBottom);
    qwtMarker->setLabelOrientation(Qt::Horizontal);
    qwtMarker->setLineStyle(QwtPlotMarker::VLine);
    qwtMarker->setLinePen(QPen(Qt::black, 0, Qt::SolidLine));
    qwtMarker->setXValue(0);
    //qwtMarker->setSymbol( new QwtSymbol( QwtSymbol::Diamond,
    //    QColor( Qt::yellow ), QColor( Qt::green ), QSize( 7, 7 ) ) );
    qwtMarker->attach(qwtPlot.get());

    grid.reset(new QwtPlotGrid);
    grid->enableXMin(false);
    grid->enableYMin(false);

    grid->setMajPen(QPen(Qt::gray, 0, Qt::DashLine));
    //grid->setMinPen(QPen(Qt::gray, 0 , Qt::DotLine));
    grid->attach(qwtPlot.get());

    qwtPlot->replot();
    return qwtPlot.get();
}


void NewChartVisualizer::getInputInfo( std::vector<core::IInputDescription::InputInfo>& info )
{
    core::IInputDescription::InputInfo input;

    input.type = typeid(ScalarChannelReaderInterface);
    input.name = "Scalar";
    input.modify = false;
    input.required = false;

    info.push_back(input);
}

core::IVisualizer::SerieBase * NewChartVisualizer::createSerie( const core::ObjectWrapperConstPtr& data, const std::string& name )
{
    NewChartSerie * ret = new NewChartSerie(this);
    ret->setName(name);
    ret->setData(data);
    series.push_back(ret);

    if(series.size() == 1){
        activeSerieCombo->blockSignals(true);
        activeSerieCombo->clear();
        activeSerieCombo->addItem(name.c_str());
        activeSerieCombo->setCurrentIndex(0);
        activeSerieCombo->blockSignals(false);
        setActiveSerie(0);
    }else{
        activeSerieCombo->addItem(name.c_str());
    }

    activeSerieCombo->setEnabled(true);

    return ret;
}

void NewChartVisualizer::addPlotCurve( QwtPlotCurve* curve, const Scales& scales)
{
    if (plotScales.initialized) {
        plotScales.xMin = std::min(plotScales.xMin, scales.xMin);
        plotScales.xMax = std::max(plotScales.xMax, scales.xMax);
        plotScales.yMin = std::min(plotScales.yMin, scales.yMin);
        plotScales.yMax = std::max(plotScales.yMax, scales.yMax);
    } else {
        plotScales = scales;
    }

    qwtPlot->setAxisScale(QwtPlot::xBottom, plotScales.xMin, plotScales.xMax);
    qwtPlot->setAxisScale(QwtPlot::yLeft, plotScales.yMin, plotScales.yMax);
    curve->attach(qwtPlot.get());
}

void NewChartVisualizer::removeSerie( core::IVisualizer::SerieBase *serie )
{
    NewChartSerie* chSerie = dynamic_cast<NewChartSerie*>(serie);

    if(chSerie == nullptr){
        throw std::runtime_error("Serie type not generated by this Visualizer!");
    }

    auto it = std::find(series.begin(), series.end(), chSerie);
    if(it == series.end()){
        throw std::runtime_error("Given serie dos not belong to this visualizer!");
    }

    activeSerieCombo->blockSignals(true);
    series.erase(it);

    if(series.empty() == true){
        activeSerieCombo->addItem(QString::fromUtf8("No active serie"));
        activeSerieCombo->setCurrentIndex(0);
        activeSerieCombo->setEnabled(false);
    }else{
        activeSerieCombo->clear();
        int active = 0;
        int count = series.size();
        for (int i = 0; i < count; i++) {
            NewChartSerie* serie = series[i];
            activeSerieCombo->addItem(serie->getName().c_str());
            if (serie->getActive()) {
                active = i;
            }
        }

        activeSerieCombo->setCurrentIndex(active);
    }

    activeSerieCombo->blockSignals(false);
}

void NewChartVisualizer::setActiveSerie( int idx )
{
    for (int i = series.size() - 1; i >= 0; --i) {
        series[i]->setActive(idx == i);
    }
    currentSerie = idx;
}

void NewChartVisualizer::setNormalized( bool normalized )
{

}

void NewChartVisualizer::onSerieSelected( QwtPlotItem* item)
{
    QwtPlotCurve* curve = dynamic_cast<QwtPlotCurve*>(item);
    for (int i = series.size() - 1; i >= 0; --i) {
        if (series[i]->curve == curve) {
            // powinno wywolac sygnal, ktory ustawi aktywna serie
            activeSerieCombo->setCurrentIndex(i);
            return;
        }
    }
}


