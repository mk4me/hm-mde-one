/********************************************************************
	created:  2013/11/15
	created:  15:11:2013   13:54
	filename: DataSource.h
	author:   Mateusz Janiak

	purpose:  èrÛd≥o danych obs≥ugujπce kostiumy z IMU
	*********************************************************************/
#ifndef HEADER_GUARD_IMU_COSTUME__DATASOURCE_H__
#define HEADER_GUARD_IMU_COSTUME__DATASOURCE_H__

#include <plugins/imuCostume/Wrappers.h>
#include <corelib/Variant.h>
#include <corelib/ISource.h>
#include <threadingUtils/StreamData.h>
#include <osg/Vec3>
#include <mutex>
#include <imucostumelib/ImuCostume.h>
#include <imucostumelib/CostumeCANopenIO.h>
#include <imucostumelib/ProtocolSendBufferHelper.h>
#include <corelib/HierarchyItem.h>
#include <corelib/ThreadPool.h>
#include <corelib/HierarchyDataItem.h>


namespace IMU
{
	class IMUCostumeDataSource : public plugin::ISource
	{
		UNIQUE_ID("{441BB894-1019-4382-97EE-F18A511A49CB}");
		CLASS_DESCRIPTION("IMUCostume", "IMU Costume Data Source");

	public:

		enum 
		{
			AccIdx = 0,
			GyroIdx = 1,
			MagIdx = 2
		};

		enum ConnectionStatus
		{
			ONLINE,
			OFFLINE,
			CONNECTION_PROBLEMS,
			UNKNOWN
		};

		typedef threadingUtils::StreamT<imuCostume::ProtocolSendBufferHelper::Buffer> RawDataStream;

		DEFINE_SMART_POINTERS(RawDataStream);

		typedef threadingUtils::StreamT<imuCostume::CostumeCANopenIO::Data> CANopenFramesStream;

		DEFINE_SMART_POINTERS(CANopenFramesStream);

		typedef threadingUtils::IStreamT<imuCostume::Costume::Data> CostumeStream;

		DEFINE_SMART_POINTERS(CostumeStream);

	private:

		struct SensorData
		{
			utils::shared_ptr<std::atomic<ConnectionStatus>> status;
			utils::shared_ptr<IMUStream> dataStream;
			std::vector<utils::shared_ptr<Vec3Stream>> vec3dStreams;
			utils::shared_ptr<QuatStream> orientationStream;
			std::list<utils::shared_ptr<ScalarStream>> scalarStreams;
		};

		struct CostumeData
		{
			imuCostume::Costume::SensorsConfiguration sensorsConfiguration;
			utils::shared_ptr<imuCostume::CostumeRawIO> rawCostume;
			utils::shared_ptr<std::atomic<ConnectionStatus>> status;
			std::map<imuCostume::Costume::SensorID, SensorData> sensorsData;
			RawDataStreamPtr rawDataStream;
			CANopenFramesStreamPtr CANopenStream;	
			CostumeStreamPtr costumeStream;

			core::HierarchyDataItemPtr hierarchyRootItem;
			core::VariantsList domainData;
		};

	public:
		//! Konstruktor
		IMUCostumeDataSource();
		//! Destruktor wirtualny
		virtual ~IMUCostumeDataSource();

		//! Inicjalizacja ürÛd≥a. NastÍpuje juø po wczytaniu pluginÛw i skonstruowaniu
		//! (nie zainicjalizowaniu!) wszystkich ürÛde≥.
		virtual void init(core::IMemoryDataManager * memoryDM,
			core::IStreamDataManager * streamDM,
			core::IFileDataManager * fileDM);

		//! Zobacz podobnπ metode dla IService
		//! PÛüna inicjalizacja ürÛd≥a, nastÍpuje po wczytaniu i inicjalizacji wszystkich innych ürÛde≥
		virtual bool lateInit();

		//! Metoda powinna w bezpieczny sposÛb zwalniac zasoby, majπc na uwadze øe niekoniecznie wszystkie us≥ugi i zasoby pobrane z zewnπtrz sπ jeszcze dostÍpne.
		//! Ta metoda w szczegolnoscis powinna zamknac wszystkie watki, ktÛre uruchomi≥ serwis, moøe tez zwalniac pamieÊ przydzielonπ dynamicznie
		//! Generalnie to taki bezpieczny destruktor uniezaleøniajπcy dana us≥ugÍ od pozosta≥ych us≥ug i przygotowujπcy ja na usuniÍcie
		virtual void finalize();

		//! Metoda aktualizujπca pochodzi z wπtku UI! Powinny tu byÊ realizowane lekkie operacje odúwieøania widgetÛw!!
		//! Jako parametr dostajemy przyrost czasu jaki mina≥ od poprzedniego wywo≥ania
		virtual void update(double deltaTime);

		//! èrÛd≥o nie musi mieÊ wizualnej reprezentacji.
		//! \return Widget tworzony przez ürÛd≥o bπdü NULL.
		virtual QWidget* getWidget();
		//! \return Widget kontrolujπcy zachowanie us≥ugi/us≥ug zaleønych.
		virtual QWidget* getControlWidget();
		//! \return Widget dostarczajπcy opcji zwiπzanych z us≥ugπ/us≥ugami zaleønymi.
		virtual QWidget* getSettingsWidget();
		//! \param offeredTypes Typy oferowane przez to ürÛd≥o
		virtual void getOfferedTypes(utils::TypeInfoList & offeredTypes) const;

		const bool refreshCostumes();

		const unsigned int costumesCout() const;

		const imuCostume::Costume::SensorsConfiguration & costumeConfiguration(const unsigned int idx) const;
		const imuCostume::CostumeRawIO::CostumeAddress costumeAddress(const unsigned int idx) const;
		const ConnectionStatus costumeStatus(const unsigned int idx) const;
		const RawDataStreamPtr costumeRawDataStream(const unsigned int idx) const;
		const core::VariantsList costumeData(const unsigned int idx) const;

		void loadCostume(const unsigned int idx);
		void unloadCostume(const unsigned int idx);
		const bool costumeLoaded(const unsigned int idx) const;
		const unsigned int costumesLoadedCount() const;

		void loadAllCostumes();
		void unloadAllCostumes();

	private:

		static void configureCostume(CostumeData & cd);
		static void refreshCostumeSensorsConfiguration(CostumeData & cd);

		static std::string sensorParameterName(const unsigned int idx);
		static std::string vectorParameterName(const unsigned int idx);

		void refreshData();

		void innerLoadCostume(const unsigned int idx);
		void innerUnloadCostume(const unsigned int idx);		

		static core::HierarchyItemPtr createRootItem();
		static core::HierarchyItemPtr createStreamItem();
		static core::HierarchyItemPtr createRecordItem();
		static core::HierarchyItemPtr createIMUsItem();

		void generateCostumeItem(const unsigned int idx,
			const core::VariantsList & data,
			core::HierarchyItemPtr parent);

		void tryCreateRootItem();

		void tryCreateStreamItem();
		void tryCreateRecordedItem();

	private:
		//! Czy odúwieøamy dane
		std::atomic<bool> refreshData_;
		//! Obiekt synchronizujπcy
		mutable std::recursive_mutex synch;
		//! Obiekt synchronizujπcy aktualizacjÍ danych
		std::recursive_mutex updateSynch;
		//! Manager danych w pamiÍci
		core::IMemoryDataManager * memoryDM;
		//! Watek odswiezajacy dane
		core::ThreadPool::Thread refreshThread;
		//! Korzen drzewa dla analiz
		core::HierarchyItemPtr root;
		//! Dane strumieniowe
		core::HierarchyItemPtr streamItems;
		//! Dane nagrane
		core::HierarchyItemPtr recordedItems;

		std::map<std::string, CostumeData> costumesData;
	};
}

DEFINE_WRAPPER(threadingUtils::IStreamT<imuCostume::ProtocolSendBufferHelper::Buffer>, utils::PtrPolicyStd, utils::ClonePolicyNotImplemented);
DEFINE_WRAPPER_INHERITANCE(IMU::IMUCostumeDataSource::RawDataStream, threadingUtils::IStreamT<imuCostume::ProtocolSendBufferHelper::Buffer>);
DEFINE_WRAPPER(IMU::IMUCostumeDataSource::CANopenFramesStream, utils::PtrPolicyStd, utils::ClonePolicyNotImplemented);
DEFINE_WRAPPER(IMU::IMUCostumeDataSource::CostumeStream, utils::PtrPolicyStd, utils::ClonePolicyNotImplemented);

#endif	//	HEADER_GUARD_IMU_COSTUME__DATASOURCE_H__
